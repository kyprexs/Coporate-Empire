const { SlashCommandBuilder, EmbedBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('contract')
        .setDescription('Business contracts and agreements')
        .addSubcommand(subcommand =>
            subcommand
                .setName('create')
                .setDescription('Create a new business contract')
                .addStringOption(option =>
                    option
                        .setName('company')
                        .setDescription('Your company creating the contract')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option
                        .setName('counterparty')
                        .setDescription('Other company or user to contract with')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option
                        .setName('type')
                        .setDescription('Type of contract')
                        .setRequired(true)
                        .addChoices(
                            { name: 'Supply Agreement', value: 'supply' },
                            { name: 'Service Contract', value: 'service' },
                            { name: 'Partnership', value: 'partnership' },
                            { name: 'Licensing Deal', value: 'licensing' },
                            { name: 'Joint Venture', value: 'joint_venture' },
                            { name: 'Non-Disclosure Agreement', value: 'nda' },
                            { name: 'Employment Contract', value: 'employment' }
                        )
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('list')
                .setDescription('List contracts for your companies')
                .addStringOption(option =>
                    option
                        .setName('status')
                        .setDescription('Filter by contract status')
                        .addChoices(
                            { name: 'All', value: 'all' },
                            { name: 'Pending', value: 'pending' },
                            { name: 'Active', value: 'active' },
                            { name: 'Completed', value: 'completed' },
                            { name: 'Cancelled', value: 'cancelled' }
                        )
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('view')
                .setDescription('View contract details')
                .addIntegerOption(option =>
                    option
                        .setName('contract_id')
                        .setDescription('Contract ID to view')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('sign')
                .setDescription('Sign a pending contract')
                .addIntegerOption(option =>
                    option
                        .setName('contract_id')
                        .setDescription('Contract ID to sign')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('cancel')
                .setDescription('Cancel a contract (if you created it)')
                .addIntegerOption(option =>
                    option
                        .setName('contract_id')
                        .setDescription('Contract ID to cancel')
                        .setRequired(true)
                )
        ),

    async execute(interaction, client) {
        const subcommand = interaction.options.getSubcommand();

        switch (subcommand) {
            case 'create':
                await this.handleCreate(interaction, client);
                break;
            case 'list':
                await this.handleList(interaction, client);
                break;
            case 'view':
                await this.handleView(interaction, client);
                break;
            case 'sign':
                await this.handleSign(interaction, client);
                break;
            case 'cancel':
                await this.handleCancel(interaction, client);
                break;
        }
    },

    async handleCreate(interaction, client) {
        try {
            const companyQuery = interaction.options.getString('company');
            const counterpartyQuery = interaction.options.getString('counterparty');
            const contractType = interaction.options.getString('type');

            // Find the user's company
            const company = await client.db.getUserCompany(interaction.user.id, companyQuery);
            if (!company) {
                await interaction.reply({
                    content: '‚ùå Company not found or you don\'t own this company.',
                    ephemeral: true
                });
                return;
            }

            // Find counterparty (could be company or user)
            let counterparty = null;
            let counterpartyType = null;

            // First try to find as a company
            const counterpartyCompany = await client.db.db.get(`
                SELECT c.*, u.username as owner_username 
                FROM companies c
                JOIN users u ON c.owner_id = u.discord_id
                WHERE (LOWER(c.name) LIKE LOWER(?) OR LOWER(c.ticker_symbol) LIKE LOWER(?))
                AND c.status = 'active'
            `, [`%${counterpartyQuery}%`, `%${counterpartyQuery}%`]);

            if (counterpartyCompany) {
                counterparty = counterpartyCompany;
                counterpartyType = 'company';
            } else {
                // Try to find as a user by username or mention
                const username = counterpartyQuery.replace(/[@<>!]/g, '');
                const counterpartyUser = await client.db.db.get(`
                    SELECT * FROM users WHERE LOWER(username) LIKE LOWER(?)
                `, [`%${username}%`]);

                if (counterpartyUser) {
                    counterparty = counterpartyUser;
                    counterpartyType = 'user';
                } else {
                    await interaction.reply({
                        content: '‚ùå Counterparty not found. Please specify a valid company name/ticker or username.',
                        ephemeral: true
                    });
                    return;
                }
            }

            // Create modal for contract details
            const modal = new ModalBuilder()
                .setCustomId(`contract_create_${company.id}_${counterparty.id}_${counterpartyType}_${contractType}`)
                .setTitle(`Create ${this.getContractTypeName(contractType)} Contract`);

            const titleInput = new TextInputBuilder()
                .setCustomId('contract_title')
                .setLabel('Contract Title')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('Brief title for this contract')
                .setRequired(true)
                .setMaxLength(100);

            const termsInput = new TextInputBuilder()
                .setCustomId('contract_terms')
                .setLabel('Contract Terms')
                .setStyle(TextInputStyle.Paragraph)
                .setPlaceholder('Detailed terms and conditions of the contract...')
                .setRequired(true)
                .setMaxLength(2000);

            const valueInput = new TextInputBuilder()
                .setCustomId('contract_value')
                .setLabel('Contract Value ($)')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('Total monetary value of the contract')
                .setRequired(true);

            const durationInput = new TextInputBuilder()
                .setCustomId('contract_duration')
                .setLabel('Duration (months)')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('How many game months will this contract last?')
                .setRequired(true);

            const additionalInput = new TextInputBuilder()
                .setCustomId('contract_additional')
                .setLabel('Additional Terms (Optional)')
                .setStyle(TextInputStyle.Paragraph)
                .setPlaceholder('Any additional terms, conditions, or notes...')
                .setRequired(false)
                .setMaxLength(1000);

            const firstActionRow = new ActionRowBuilder().addComponents(titleInput);
            const secondActionRow = new ActionRowBuilder().addComponents(termsInput);
            const thirdActionRow = new ActionRowBuilder().addComponents(valueInput);
            const fourthActionRow = new ActionRowBuilder().addComponents(durationInput);
            const fifthActionRow = new ActionRowBuilder().addComponents(additionalInput);

            modal.addComponents(firstActionRow, secondActionRow, thirdActionRow, fourthActionRow, fifthActionRow);

            await interaction.showModal(modal);

        } catch (error) {
            console.error('Error in contract create command:', error);
            await interaction.reply({
                content: '‚ùå There was an error creating the contract.',
                ephemeral: true
            });
        }
    },

    async handleList(interaction, client) {
        try {
            const statusFilter = interaction.options.getString('status') || 'all';

            // Get user's companies
            const companies = await client.db.db.all(`
                SELECT id FROM companies WHERE owner_id = ? AND status = 'active'
            `, [interaction.user.id]);

            if (companies.length === 0) {
                await interaction.reply({
                    content: '‚ùå You don\'t own any companies.',
                    ephemeral: true
                });
                return;
            }

            const companyIds = companies.map(c => c.id);
            const placeholders = companyIds.map(() => '?').join(',');

            // Build query based on status filter
            let whereClause = `WHERE (party_a_id IN (${placeholders}) OR party_b_id IN (${placeholders}))`;
            const queryParams = [...companyIds, ...companyIds];

            if (statusFilter !== 'all') {
                whereClause += ' AND status = ?';
                queryParams.push(statusFilter);
            }

            // Get contracts
            const contracts = await client.db.db.all(`
                SELECT 
                    c.*,
                    ca.name as party_a_name, ca.ticker_symbol as party_a_ticker,
                    cb.name as party_b_name, cb.ticker_symbol as party_b_ticker,
                    ua.username as party_a_owner, ub.username as party_b_owner
                FROM contracts c
                JOIN companies ca ON c.party_a_id = ca.id
                JOIN companies cb ON c.party_b_id = cb.id
                JOIN users ua ON ca.owner_id = ua.discord_id
                JOIN users ub ON cb.owner_id = ub.discord_id
                ${whereClause}
                ORDER BY c.created_at DESC
                LIMIT 20
            `, queryParams);

            if (contracts.length === 0) {
                await interaction.reply({
                    content: `üìã No ${statusFilter === 'all' ? '' : statusFilter + ' '}contracts found for your companies.`,
                    ephemeral: true
                });
                return;
            }

            const embed = new EmbedBuilder()
                .setTitle(`üìã Your Contracts ${statusFilter !== 'all' ? `(${statusFilter})` : ''}`)
                .setColor(0x0099FF)
                .setDescription(`Found ${contracts.length} contract${contracts.length !== 1 ? 's' : ''}`)
                .setTimestamp()
                .setFooter({ text: 'Corporate Empire Legal Department' });

            let contractList = '';
            contracts.forEach((contract, index) => {
                const statusIcon = this.getContractStatusIcon(contract.status);
                const typeIcon = this.getContractTypeIcon(contract.contract_type);
                
                contractList += `${statusIcon} **ID: ${contract.id}** ${typeIcon} ${this.getContractTypeName(contract.contract_type)}\\n`;
                contractList += `**${contract.party_a_name}** ‚Üî **${contract.party_b_name}**\\n`;
                contractList += `Value: $${contract.contract_value.toLocaleString()} ‚Ä¢ Duration: ${contract.duration_months} months\\n`;
                contractList += `Created: <t:${Math.floor(new Date(contract.created_at).getTime() / 1000)}:R>\\n\\n`;
            });

            embed.addFields({
                name: 'Contracts',
                value: contractList,
                inline: false
            });

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('contracts_pending')
                        .setLabel('‚è≥ Pending')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('contracts_active')
                        .setLabel('‚úÖ Active')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('contracts_all')
                        .setLabel('üìã All')
                        .setStyle(ButtonStyle.Secondary)
                );

            await interaction.reply({ embeds: [embed], components: [actionRow] });

        } catch (error) {
            console.error('Error in contract list command:', error);
            await interaction.reply({
                content: '‚ùå There was an error listing contracts.',
                ephemeral: true
            });
        }
    },

    async handleView(interaction, client) {
        try {
            const contractId = interaction.options.getInteger('contract_id');

            // Get contract details
            const contract = await client.db.db.get(`
                SELECT 
                    c.*,
                    ca.name as party_a_name, ca.ticker_symbol as party_a_ticker,
                    cb.name as party_b_name, cb.ticker_symbol as party_b_ticker,
                    ua.username as party_a_owner, ub.username as party_b_owner
                FROM contracts c
                JOIN companies ca ON c.party_a_id = ca.id
                JOIN companies cb ON c.party_b_id = cb.id
                JOIN users ua ON ca.owner_id = ua.discord_id
                JOIN users ub ON cb.owner_id = ub.discord_id
                WHERE c.id = ?
            `, [contractId]);

            if (!contract) {
                await interaction.reply({
                    content: '‚ùå Contract not found.',
                    ephemeral: true
                });
                return;
            }

            // Check if user is involved in this contract
            const userCompanies = await client.db.db.all(`
                SELECT id FROM companies WHERE owner_id = ? AND status = 'active'
            `, [interaction.user.id]);

            const userCompanyIds = userCompanies.map(c => c.id);
            const isInvolved = userCompanyIds.includes(contract.party_a_id) || userCompanyIds.includes(contract.party_b_id);

            if (!isInvolved) {
                await interaction.reply({
                    content: '‚ùå You can only view contracts involving your companies.',
                    ephemeral: true
                });
                return;
            }

            const statusIcon = this.getContractStatusIcon(contract.status);
            const typeIcon = this.getContractTypeIcon(contract.contract_type);

            const embed = new EmbedBuilder()
                .setTitle(`${typeIcon} Contract #${contract.id}: ${contract.title}`)
                .setColor(this.getContractStatusColor(contract.status))
                .setDescription(contract.terms)
                .addFields(
                    { name: 'Status', value: `${statusIcon} ${contract.status.charAt(0).toUpperCase() + contract.status.slice(1)}`, inline: true },
                    { name: 'Type', value: this.getContractTypeName(contract.contract_type), inline: true },
                    { name: 'Contract Value', value: `$${contract.contract_value.toLocaleString()}`, inline: true },
                    { name: 'Party A', value: `${contract.party_a_name} (${contract.party_a_ticker || 'Private'})\\nOwner: ${contract.party_a_owner}`, inline: true },
                    { name: 'Party B', value: `${contract.party_b_name} (${contract.party_b_ticker || 'Private'})\\nOwner: ${contract.party_b_owner}`, inline: true },
                    { name: 'Duration', value: `${contract.duration_months} months`, inline: true },
                    { name: 'Created', value: `<t:${Math.floor(new Date(contract.created_at).getTime() / 1000)}:D>`, inline: true }
                )
                .setTimestamp()
                .setFooter({ text: 'Corporate Empire Legal Department' });

            if (contract.signed_at) {
                embed.addFields({
                    name: 'Signed Date', 
                    value: `<t:${Math.floor(new Date(contract.signed_at).getTime() / 1000)}:D>`, 
                    inline: true
                });
            }

            if (contract.end_date) {
                embed.addFields({
                    name: 'End Date', 
                    value: `<t:${Math.floor(new Date(contract.end_date).getTime() / 1000)}:D>`, 
                    inline: true
                });
            }

            if (contract.additional_terms) {
                embed.addFields({
                    name: 'Additional Terms',
                    value: contract.additional_terms,
                    inline: false
                });
            }

            // Create action buttons based on contract status and user's role
            const actionRow = new ActionRowBuilder();

            if (contract.status === 'pending') {
                // Check if this user can sign (owns party B company)
                const canSign = userCompanyIds.includes(contract.party_b_id);
                if (canSign) {
                    actionRow.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`contract_sign_${contract.id}`)
                            .setLabel('‚úçÔ∏è Sign Contract')
                            .setStyle(ButtonStyle.Success)
                    );
                }

                // Check if this user can cancel (owns party A company)
                const canCancel = userCompanyIds.includes(contract.party_a_id);
                if (canCancel) {
                    actionRow.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`contract_cancel_${contract.id}`)
                            .setLabel('‚ùå Cancel Contract')
                            .setStyle(ButtonStyle.Danger)
                    );
                }
            }

            const components = actionRow.components.length > 0 ? [actionRow] : [];
            await interaction.reply({ embeds: [embed], components });

        } catch (error) {
            console.error('Error in contract view command:', error);
            await interaction.reply({
                content: '‚ùå There was an error viewing the contract.',
                ephemeral: true
            });
        }
    },

    async handleSign(interaction, client) {
        try {
            const contractId = interaction.options.getInteger('contract_id');

            // Get contract details
            const contract = await client.db.db.get(`
                SELECT 
                    c.*,
                    ca.name as party_a_name, cb.name as party_b_name,
                    ca.owner_id as party_a_owner_id, cb.owner_id as party_b_owner_id
                FROM contracts c
                JOIN companies ca ON c.party_a_id = ca.id
                JOIN companies cb ON c.party_b_id = cb.id
                WHERE c.id = ? AND c.status = 'pending'
            `, [contractId]);

            if (!contract) {
                await interaction.reply({
                    content: '‚ùå Contract not found or already signed/cancelled.',
                    ephemeral: true
                });
                return;
            }

            // Check if user owns party B company (the one who needs to sign)
            if (contract.party_b_owner_id !== interaction.user.id) {
                await interaction.reply({
                    content: '‚ùå Only the counterparty can sign this contract.',
                    ephemeral: true
                });
                return;
            }

            // Process contract signing
            const now = new Date().toISOString();
            const endDate = new Date();
            endDate.setMonth(endDate.getMonth() + contract.duration_months);

            await client.db.db.run(`
                UPDATE contracts 
                SET status = 'active', signed_at = ?, end_date = ?
                WHERE id = ?
            `, [now, endDate.toISOString(), contractId]);

            // Process any immediate contract effects based on type
            await this.processContractActivation(client, contract);

            const embed = new EmbedBuilder()
                .setTitle('‚úÖ Contract Signed Successfully!')
                .setColor(0x00FF00)
                .addFields(
                    { name: 'Contract', value: `#${contract.id}: ${contract.title}`, inline: true },
                    { name: 'Parties', value: `${contract.party_a_name} ‚Üî ${contract.party_b_name}`, inline: true },
                    { name: 'Value', value: `$${contract.contract_value.toLocaleString()}`, inline: true },
                    { name: 'Duration', value: `${contract.duration_months} months`, inline: true },
                    { name: 'End Date', value: `<t:${Math.floor(endDate.getTime() / 1000)}:D>`, inline: true }
                )
                .setDescription('üéâ The contract is now active and legally binding!')
                .setTimestamp()
                .setFooter({ text: 'Corporate Empire Legal Department' });

            await interaction.reply({ embeds: [embed] });

            // Notify the contract creator
            try {
                const creatorUser = await client.users.fetch(contract.party_a_owner_id);
                if (creatorUser && creatorUser.id !== interaction.user.id) {
                    const notificationEmbed = new EmbedBuilder()
                        .setTitle('‚úÖ Contract Signed')
                        .setColor(0x00FF00)
                        .setDescription(`Your contract "${contract.title}" has been signed by ${contract.party_b_name}!`)
                        .addFields(
                            { name: 'Contract ID', value: contract.id.toString(), inline: true },
                            { name: 'Value', value: `$${contract.contract_value.toLocaleString()}`, inline: true }
                        );

                    await creatorUser.send({ embeds: [notificationEmbed] });
                }
            } catch (notifyError) {
                console.log('Could not notify contract creator:', notifyError.message);
            }

        } catch (error) {
            console.error('Error in contract sign command:', error);
            await interaction.reply({
                content: '‚ùå There was an error signing the contract.',
                ephemeral: true
            });
        }
    },

    async handleCancel(interaction, client) {
        try {
            const contractId = interaction.options.getInteger('contract_id');

            // Get contract details
            const contract = await client.db.db.get(`
                SELECT 
                    c.*,
                    ca.name as party_a_name, ca.owner_id as party_a_owner_id
                FROM contracts c
                JOIN companies ca ON c.party_a_id = ca.id
                WHERE c.id = ? AND c.status = 'pending'
            `, [contractId]);

            if (!contract) {
                await interaction.reply({
                    content: '‚ùå Contract not found or cannot be cancelled (only pending contracts can be cancelled).',
                    ephemeral: true
                });
                return;
            }

            // Check if user owns party A company (the creator)
            if (contract.party_a_owner_id !== interaction.user.id) {
                await interaction.reply({
                    content: '‚ùå Only the contract creator can cancel pending contracts.',
                    ephemeral: true
                });
                return;
            }

            // Cancel the contract
            await client.db.db.run(`
                UPDATE contracts 
                SET status = 'cancelled'
                WHERE id = ?
            `, [contractId]);

            const embed = new EmbedBuilder()
                .setTitle('‚ùå Contract Cancelled')
                .setColor(0xFF6B6B)
                .addFields(
                    { name: 'Contract', value: `#${contract.id}: ${contract.title}`, inline: true },
                    { name: 'Value', value: `$${contract.contract_value.toLocaleString()}`, inline: true }
                )
                .setDescription('The contract has been cancelled and is no longer available for signing.')
                .setTimestamp()
                .setFooter({ text: 'Corporate Empire Legal Department' });

            await interaction.reply({ embeds: [embed] });

        } catch (error) {
            console.error('Error in contract cancel command:', error);
            await interaction.reply({
                content: '‚ùå There was an error cancelling the contract.',
                ephemeral: true
            });
        }
    },

    async processContractActivation(client, contract) {
        try {
            // Process different contract types when activated
            switch (contract.contract_type) {
                case 'supply':
                case 'service':
                    // Process payment for supply/service contracts
                    await client.db.db.run(`
                        UPDATE companies 
                        SET cash = cash + ?
                        WHERE id = ?
                    `, [contract.contract_value, contract.party_a_id]);

                    await client.db.db.run(`
                        UPDATE companies 
                        SET cash = cash - ?
                        WHERE id = ?
                    `, [contract.contract_value, contract.party_b_id]);
                    break;

                case 'partnership':
                case 'joint_venture':
                    // For partnerships, split the value
                    const splitValue = contract.contract_value / 2;
                    await client.db.db.run(`
                        UPDATE companies 
                        SET cash = cash + ?
                        WHERE id IN (?, ?)
                    `, [splitValue, contract.party_a_id, contract.party_b_id]);
                    break;

                case 'licensing':
                    // Licensing fee goes to party A
                    await client.db.db.run(`
                        UPDATE companies 
                        SET cash = cash + ?
                        WHERE id = ?
                    `, [contract.contract_value, contract.party_a_id]);

                    await client.db.db.run(`
                        UPDATE companies 
                        SET cash = cash - ?
                        WHERE id = ?
                    `, [contract.contract_value, contract.party_b_id]);
                    break;

                default:
                    // For other types like NDA, employment, no immediate financial impact
                    break;
            }

        } catch (error) {
            console.error('Error processing contract activation:', error);
        }
    },

    getContractTypeName(type) {
        const types = {
            'supply': 'Supply Agreement',
            'service': 'Service Contract', 
            'partnership': 'Partnership',
            'licensing': 'Licensing Deal',
            'joint_venture': 'Joint Venture',
            'nda': 'Non-Disclosure Agreement',
            'employment': 'Employment Contract'
        };
        return types[type] || type;
    },

    getContractTypeIcon(type) {
        const icons = {
            'supply': 'üì¶',
            'service': 'üîß',
            'partnership': 'ü§ù',
            'licensing': 'üìÑ',
            'joint_venture': 'üèóÔ∏è',
            'nda': 'ü§ê',
            'employment': 'üëî'
        };
        return icons[type] || 'üìã';
    },

    getContractStatusIcon(status) {
        const icons = {
            'pending': '‚è≥',
            'active': '‚úÖ',
            'completed': 'üèÅ',
            'cancelled': '‚ùå',
            'expired': '‚è∞'
        };
        return icons[status] || 'üìã';
    },

    getContractStatusColor(status) {
        const colors = {
            'pending': 0xFFD700,
            'active': 0x00FF00,
            'completed': 0x32CD32,
            'cancelled': 0xFF6B6B,
            'expired': 0x808080
        };
        return colors[status] || 0x0099FF;
    }
};
